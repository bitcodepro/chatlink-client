<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Player</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000;
            color: #fff;
        }

        .container {
            text-align: center;
        }

        .full-screen-video {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 1000;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        .hidden {
            display: none;
        }

        #localVideo {
            height: 100px;
            width: 100px;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <svg id="videoBtn" width="40px" height="40px" viewBox="0 0 48 48" version="1" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 48 48">
            <path fill="#0BBD8B" d="M8,12h22c2.2,0,4,1.8,4,4v16c0,2.2-1.8,4-4,4H8c-2.2,0-4-1.8-4-4V16C4,13.8,5.8,12,8,12z" />
            <polygon fill="#0BBD8B" points="44,35 34,29 34,19 44,13" />
        </svg>
        <svg id="audioBtn" fill="#000000" width="35px" height="35px" viewBox="0 0 32 32" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;" version="1.1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:serif="http://www.serif.com/" xmlns:xlink="http://www.w3.org/1999/xlink">
        <g transform="matrix(1,0,0,1,-192,-192)">
        <g transform="matrix(0.866025,-0.5,0.5,0.866025,-80.8359,134.738)">
        <path d="M217,197C217,195.895 216.105,195 215,195L213.766,195C210.625,195 207.868,197.092 207.024,200.118C205.549,205.376 205.549,210.624 207.053,215.873C207.893,218.886 210.638,220.97 213.766,220.97C214.197,221 214.615,221 215,221C216.105,221 217,220.105 217,219L217,215C217,214.47 216.789,213.961 216.414,213.586C216.039,213.211 215.53,213 215,213L213.404,213C212.519,213 211.739,212.419 211.486,211.571C210.829,209.188 210.829,206.812 211.508,204.436C211.757,203.597 212.528,203.022 213.404,203.022C213.899,203 214.465,203 215,203C215.53,203 216.039,202.789 216.414,202.414C216.789,202.039 217,201.53 217,201L217,197Z" style="fill:rgb(11, 189, 139);" /></g>
        <g transform="matrix(0.866025,-0.5,0.5,0.866025,-80.8359,134.738)">
        <path d="M218,197C218,195.343 216.657,194 215,194L213.766,194C210.176,194 207.026,196.391 206.061,199.849C204.535,205.287 204.535,210.717 206.091,216.146C207.051,219.58 210.174,221.957 213.737,221.97C214.167,221.999 214.6,222 215,222C215,222 215,222 215,222C216.657,222 218,220.657 218,219L218,215C218,214.204 217.684,213.441 217.121,212.879C216.559,212.316 215.796,212 215,212L213.403,212C212.965,212 212.578,211.715 212.448,211.297C211.844,209.097 211.843,206.907 212.467,204.717C212.592,204.304 212.972,204.022 213.404,204.022C213.418,204.022 213.433,204.021 213.447,204.021C213.929,204 214.48,204 215,204C215.796,204 216.559,203.684 217.121,203.121C217.684,202.559 218,201.796 218,201L218,197ZM216,197L216,201C216,201.265 215.895,201.52 215.707,201.707C215.52,201.895 215.265,202 215,202C215,202 215,202 215,202C214.458,202 213.884,202 213.381,202.022C212.072,202.032 210.923,202.895 210.549,204.15C210.548,204.154 210.547,204.158 210.546,204.161C209.816,206.717 209.815,209.274 210.522,211.837C210.524,211.843 210.526,211.849 210.528,211.856C210.907,213.128 212.077,214 213.404,214L215,214C215.265,214 215.52,214.105 215.707,214.293C215.895,214.48 216,214.735 216,215C216,215 216,219 216,219C216,219.552 215.552,220 215,220C214.637,220 214.242,220.001 213.835,219.973C213.812,219.971 213.789,219.97 213.766,219.97C211.087,219.97 208.736,218.185 208.016,215.605C208.015,215.602 208.015,215.6 208.014,215.598C206.562,210.531 206.562,205.464 207.986,200.389C207.987,200.388 207.987,200.388 207.987,200.387C208.711,197.794 211.074,196 213.766,196L215,196C215.552,196 216,196.448 216,197Z" style="fill:rgb(11, 189, 139);" />
                </g>
            </g>
        </svg>

        <svg id="acceptCall" class="hidden" width="35px" height="35px" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <style>
                    .cls-1 {
                        fill: #0BBD8B;
                        fill-rule: evenodd;
                    }
                </style>
            </defs>
            <path class="cls-1" d="M800,510a30,30,0,1,1,30-30A30,30,0,0,1,800,510Zm-16.986-23.235a3.484,3.484,0,0,1,0-4.9l1.766-1.756a3.185,3.185,0,0,1,4.574.051l3.12,3.237a1.592,1.592,0,0,0,2.311,0l15.9-16.39a3.187,3.187,0,0,1,4.6-.027L817,468.714a3.482,3.482,0,0,1,0,4.846l-21.109,21.451a3.185,3.185,0,0,1-4.552.03Z" id="check" transform="translate(-770 -450)" />
        </svg>
        <svg id="rejectCall" class="hidden" width="45px" height="45px" viewBox="0 -0.5 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M9.66501 14.835C10.5688 15.7395 11.6033 16.503 12.734 17.1C13.5954 17.602 14.5562 17.9092 15.549 18C16.0917 18.0421 16.6295 17.8718 17.049 17.525C17.095 17.485 17.384 17.196 17.691 16.883C18.199 16.364 18.258 16.294 18.355 16.102C18.5467 15.7609 18.5486 15.3449 18.36 15.002C18.26 14.795 18.234 14.767 17.33 13.866C16.453 12.992 16.393 12.937 16.214 12.853C15.8468 12.6718 15.4122 12.6926 15.064 12.908C14.8419 13.0882 14.6306 13.2812 14.431 13.486L14.108 13.804C13.989 13.9201 13.8085 13.9456 13.662 13.867C13.033 13.5088 12.4574 13.0641 11.952 12.546L9.66501 14.835Z" stroke="#FF0D00" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
            <path d="M7.3914 13.241C7.62721 13.5815 8.09443 13.6664 8.43497 13.4306C8.77551 13.1948 8.86041 12.7276 8.6246 12.387L7.3914 13.241ZM7.314 11.63L7.9878 11.3006C7.97981 11.2843 7.97123 11.2682 7.96208 11.2525L7.314 11.63ZM6.514 8.596L5.76606 8.54043C5.76491 8.55598 5.76424 8.57156 5.76405 8.58715L6.514 8.596ZM7.254 7.168L7.73068 7.74703C7.75445 7.72746 7.77699 7.70645 7.79818 7.68411L7.254 7.168ZM8.596 6.047L8.40521 5.32167C8.39233 5.32506 8.37954 5.32879 8.36685 5.33286L8.596 6.047ZM9.276 6.037L9.48591 5.31697C9.4725 5.31306 9.45898 5.30953 9.44538 5.30638L9.276 6.037ZM10.616 7.151L11.1451 6.61942L11.145 6.6193L10.616 7.151ZM11.632 8.251L10.9628 8.58971C10.9659 8.59584 10.9691 8.60192 10.9724 8.60796L11.632 8.251ZM11.7 9.2L10.9962 8.94072L10.9938 8.94756L11.7 9.2ZM10.977 10.109L11.5081 10.6385L11.5089 10.6378L10.977 10.109ZM10.641 10.446L10.1099 9.91645L10.1069 9.91948L10.641 10.446ZM9.92133 11.1256C10.11 11.4944 10.5619 11.6404 10.9306 11.4517C11.2994 11.263 11.4454 10.8111 11.2567 10.4424L9.92133 11.1256ZM4.96967 18.4697C4.67678 18.7626 4.67678 19.2374 4.96967 19.5303C5.26256 19.8232 5.73744 19.8232 6.03033 19.5303L4.96967 18.4697ZM10.1953 15.3653C10.4882 15.0724 10.4882 14.5976 10.1953 14.3047C9.90244 14.0118 9.42756 14.0118 9.13467 14.3047L10.1953 15.3653ZM20.0303 5.53033C20.3232 5.23744 20.3232 4.76256 20.0303 4.46967C19.7374 4.17678 19.2626 4.17678 18.9697 4.46967L20.0303 5.53033ZM11.4227 12.0167C11.1298 12.3096 11.1298 12.7844 11.4227 13.0773C11.7156 13.3702 12.1904 13.3702 12.4833 13.0773L11.4227 12.0167ZM8.6246 12.387C8.38529 12.0414 8.17241 11.6783 7.9878 11.3006L6.6402 11.9594C6.85799 12.4049 7.1091 12.8333 7.3914 13.241L8.6246 12.387ZM7.96208 11.2525C7.49425 10.4493 7.25298 9.5343 7.26395 8.60485L5.76405 8.58715C5.74988 9.78783 6.06156 10.9699 6.66592 12.0075L7.96208 11.2525ZM7.26194 8.65157C7.28816 8.29871 7.4575 7.97192 7.73068 7.74703L6.77732 6.58897C6.18798 7.07413 5.82262 7.77917 5.76606 8.54043L7.26194 8.65157ZM7.79818 7.68411C8.58601 6.85343 8.72136 6.79444 8.82515 6.76114L8.36685 5.33286C7.82864 5.50556 7.42999 5.89257 6.70982 6.65189L7.79818 7.68411ZM8.78679 6.77233C8.89144 6.7448 9.00121 6.74319 9.10662 6.76762L9.44538 5.30638C9.10256 5.2269 8.74554 5.23215 8.40521 5.32167L8.78679 6.77233ZM9.06609 6.75703C9.09619 6.7658 9.11061 6.77061 9.119 6.77371C9.12545 6.77609 9.127 6.77698 9.12733 6.77715C9.12775 6.77737 9.14993 6.78841 9.21393 6.84166C9.35882 6.96221 9.59092 7.18914 10.087 7.6827L11.145 6.6193C10.6731 6.14986 10.3827 5.86279 10.1733 5.68859C10.0602 5.59447 9.94731 5.51294 9.82008 5.4467C9.69097 5.37947 9.57541 5.34307 9.48591 5.31697L9.06609 6.75703ZM10.0869 7.68258C10.5168 8.11044 10.7367 8.33166 10.8608 8.46613C10.9212 8.53155 10.9445 8.56112 10.9531 8.57294C10.9561 8.57701 10.9561 8.57632 10.9628 8.58971L12.3012 7.91229C12.2184 7.74877 12.1288 7.62833 11.9632 7.44887C11.8123 7.28534 11.5652 7.03756 11.1451 6.61942L10.0869 7.68258ZM10.9724 8.60796C11.0278 8.71031 11.0365 8.83153 10.9962 8.94073L12.4038 9.45927C12.593 8.94564 12.5521 8.37544 12.2916 7.89404L10.9724 8.60796ZM10.9938 8.94756C10.9752 8.99945 10.9802 9.04205 10.4451 9.58021L11.5089 10.6378C12.0038 10.1399 12.2568 9.87055 12.4062 9.45244L10.9938 8.94756ZM10.4459 9.57946L10.1099 9.91646L11.1721 10.9755L11.5081 10.6385L10.4459 9.57946ZM10.1069 9.91948C9.79145 10.2395 9.71665 10.7256 9.92133 11.1256L11.2567 10.4424C11.3466 10.6182 11.3138 10.8319 11.1751 10.9725L10.1069 9.91948ZM6.03033 19.5303L10.1953 15.3653L9.13467 14.3047L4.96967 18.4697L6.03033 19.5303ZM18.9697 4.46967L11.4227 12.0167L12.4833 13.0773L20.0303 5.53033L18.9697 4.46967Z" fill="#FF0D00" />
        </svg>
    </div>
    <div id="videoContainer" class="full-screen-video">
        <video id="remoteVideo" autoplay></video>
        <video id="localVideo" autoplay></video>

        <div class="controls">
            <svg id="closeBtn" width="45px" height="45px" viewBox="0 -0.5 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M9.66501 14.835C10.5688 15.7395 11.6033 16.503 12.734 17.1C13.5954 17.602 14.5562 17.9092 15.549 18C16.0917 18.0421 16.6295 17.8718 17.049 17.525C17.095 17.485 17.384 17.196 17.691 16.883C18.199 16.364 18.258 16.294 18.355 16.102C18.5467 15.7609 18.5486 15.3449 18.36 15.002C18.26 14.795 18.234 14.767 17.33 13.866C16.453 12.992 16.393 12.937 16.214 12.853C15.8468 12.6718 15.4122 12.6926 15.064 12.908C14.8419 13.0882 14.6306 13.2812 14.431 13.486L14.108 13.804C13.989 13.9201 13.8085 13.9456 13.662 13.867C13.033 13.5088 12.4574 13.0641 11.952 12.546L9.66501 14.835Z" stroke="#FF0D00" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M7.3914 13.241C7.62721 13.5815 8.09443 13.6664 8.43497 13.4306C8.77551 13.1948 8.86041 12.7276 8.6246 12.387L7.3914 13.241ZM7.314 11.63L7.9878 11.3006C7.97981 11.2843 7.97123 11.2682 7.96208 11.2525L7.314 11.63ZM6.514 8.596L5.76606 8.54043C5.76491 8.55598 5.76424 8.57156 5.76405 8.58715L6.514 8.596ZM7.254 7.168L7.73068 7.74703C7.75445 7.72746 7.77699 7.70645 7.79818 7.68411L7.254 7.168ZM8.596 6.047L8.40521 5.32167C8.39233 5.32506 8.37954 5.32879 8.36685 5.33286L8.596 6.047ZM9.276 6.037L9.48591 5.31697C9.4725 5.31306 9.45898 5.30953 9.44538 5.30638L9.276 6.037ZM10.616 7.151L11.1451 6.61942L11.145 6.6193L10.616 7.151ZM11.632 8.251L10.9628 8.58971C10.9659 8.59584 10.9691 8.60192 10.9724 8.60796L11.632 8.251ZM11.7 9.2L10.9962 8.94072L10.9938 8.94756L11.7 9.2ZM10.977 10.109L11.5081 10.6385L11.5089 10.6378L10.977 10.109ZM10.641 10.446L10.1099 9.91645L10.1069 9.91948L10.641 10.446ZM9.92133 11.1256C10.11 11.4944 10.5619 11.6404 10.9306 11.4517C11.2994 11.263 11.4454 10.8111 11.2567 10.4424L9.92133 11.1256ZM4.96967 18.4697C4.67678 18.7626 4.67678 19.2374 4.96967 19.5303C5.26256 19.8232 5.73744 19.8232 6.03033 19.5303L4.96967 18.4697ZM10.1953 15.3653C10.4882 15.0724 10.4882 14.5976 10.1953 14.3047C9.90244 14.0118 9.42756 14.0118 9.13467 14.3047L10.1953 15.3653ZM20.0303 5.53033C20.3232 5.23744 20.3232 4.76256 20.0303 4.46967C19.7374 4.17678 19.2626 4.17678 18.9697 4.46967L20.0303 5.53033ZM11.4227 12.0167C11.1298 12.3096 11.1298 12.7844 11.4227 13.0773C11.7156 13.3702 12.1904 13.3702 12.4833 13.0773L11.4227 12.0167ZM8.6246 12.387C8.38529 12.0414 8.17241 11.6783 7.9878 11.3006L6.6402 11.9594C6.85799 12.4049 7.1091 12.8333 7.3914 13.241L8.6246 12.387ZM7.96208 11.2525C7.49425 10.4493 7.25298 9.5343 7.26395 8.60485L5.76405 8.58715C5.74988 9.78783 6.06156 10.9699 6.66592 12.0075L7.96208 11.2525ZM7.26194 8.65157C7.28816 8.29871 7.4575 7.97192 7.73068 7.74703L6.77732 6.58897C6.18798 7.07413 5.82262 7.77917 5.76606 8.54043L7.26194 8.65157ZM7.79818 7.68411C8.58601 6.85343 8.72136 6.79444 8.82515 6.76114L8.36685 5.33286C7.82864 5.50556 7.42999 5.89257 6.70982 6.65189L7.79818 7.68411ZM8.78679 6.77233C8.89144 6.7448 9.00121 6.74319 9.10662 6.76762L9.44538 5.30638C9.10256 5.2269 8.74554 5.23215 8.40521 5.32167L8.78679 6.77233ZM9.06609 6.75703C9.09619 6.7658 9.11061 6.77061 9.119 6.77371C9.12545 6.77609 9.127 6.77698 9.12733 6.77715C9.12775 6.77737 9.14993 6.78841 9.21393 6.84166C9.35882 6.96221 9.59092 7.18914 10.087 7.6827L11.145 6.6193C10.6731 6.14986 10.3827 5.86279 10.1733 5.68859C10.0602 5.59447 9.94731 5.51294 9.82008 5.4467C9.69097 5.37947 9.57541 5.34307 9.48591 5.31697L9.06609 6.75703ZM10.0869 7.68258C10.5168 8.11044 10.7367 8.33166 10.8608 8.46613C10.9212 8.53155 10.9445 8.56112 10.9531 8.57294C10.9561 8.57701 10.9561 8.57632 10.9628 8.58971L12.3012 7.91229C12.2184 7.74877 12.1288 7.62833 11.9632 7.44887C11.8123 7.28534 11.5652 7.03756 11.1451 6.61942L10.0869 7.68258ZM10.9724 8.60796C11.0278 8.71031 11.0365 8.83153 10.9962 8.94073L12.4038 9.45927C12.593 8.94564 12.5521 8.37544 12.2916 7.89404L10.9724 8.60796ZM10.9938 8.94756C10.9752 8.99945 10.9802 9.04205 10.4451 9.58021L11.5089 10.6378C12.0038 10.1399 12.2568 9.87055 12.4062 9.45244L10.9938 8.94756ZM10.4459 9.57946L10.1099 9.91646L11.1721 10.9755L11.5081 10.6385L10.4459 9.57946ZM10.1069 9.91948C9.79145 10.2395 9.71665 10.7256 9.92133 11.1256L11.2567 10.4424C11.3466 10.6182 11.3138 10.8319 11.1751 10.9725L10.1069 9.91948ZM6.03033 19.5303L10.1953 15.3653L9.13467 14.3047L4.96967 18.4697L6.03033 19.5303ZM18.9697 4.46967L11.4227 12.0167L12.4833 13.0773L20.0303 5.53033L18.9697 4.46967Z" fill="#FF0D00" />
            </svg>
            <svg id="muteBtn" fill="#0BBD8B" width="30px" height="30px" viewBox="0 0 1920 1920" xmlns="http://www.w3.org/2000/svg">
                <path d="M1129.432 113v1694.148H936.638l-451.773-451.773h-315.45C76.01 1355.375 0 1279.365 0 1185.96V734.187c0-93.404 76.01-169.414 169.415-169.414h315.45L936.638 113h192.794Zm-112.943 112.943h-33.093l-418.68 418.68v630.901l418.68 418.68h33.093V225.944Zm655.488 135.114C1831.904 521.097 1920 733.77 1920 960.107c0 226.226-88.096 438.898-248.023 598.938l-79.851-79.85c138.694-138.695 214.93-323.018 214.93-519.087 0-196.183-76.236-380.506-214.93-519.2Zm-239.112 239.745c95.663 97.018 148.294 224.644 148.294 359.272s-52.631 262.254-148.294 359.272l-80.529-79.286c74.769-75.785 115.88-175.175 115.88-279.986 0-104.811-41.111-204.201-115.88-279.986Zm-981.092 76.914H169.415c-31.06 0-56.472 25.3-56.472 56.471v451.773c0 31.172 25.412 56.472 56.472 56.472h282.358V677.716Z" fill-rule="evenodd" />
            </svg>
        </div>
    </div>

<script>

    var t, e; t = self, e = () => (() => { var t = { d: (e, s) => { for (var i in s) t.o(s, i) && !t.o(e, i) && Object.defineProperty(e, i, { enumerable: !0, get: s[i] }) } }; t.g = function () { if ("object" == typeof globalThis) return globalThis; try { return this || new Function("return this")() } catch (t) { if ("object" == typeof window) return window } }(), t.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), t.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "t", { value: !0 }) }; var e, s = {}; t.r(s), t.d(s, { AbortError: () => r, DefaultHttpClient: () => H, HttpClient: () => d, HttpError: () => i, HttpResponse: () => u, HttpTransportType: () => F, HubConnection: () => q, HubConnectionBuilder: () => tt, HubConnectionState: () => A, JsonHubProtocol: () => Y, LogLevel: () => e, MessageType: () => x, NullLogger: () => f, Subject: () => U, TimeoutError: () => n, TransferFormat: () => B, VERSION: () => p }); class i extends Error { constructor(t, e) { const s = new.target.prototype; super(`${t}: Status code '${e}'`), this.statusCode = e, this.__proto__ = s } } class n extends Error { constructor(t = "A timeout occurred.") { const e = new.target.prototype; super(t), this.__proto__ = e } } class r extends Error { constructor(t = "An abort occurred.") { const e = new.target.prototype; super(t), this.__proto__ = e } } class o extends Error { constructor(t, e) { const s = new.target.prototype; super(t), this.transport = e, this.errorType = "UnsupportedTransportError", this.__proto__ = s } } class h extends Error { constructor(t, e) { const s = new.target.prototype; super(t), this.transport = e, this.errorType = "DisabledTransportError", this.__proto__ = s } } class c extends Error { constructor(t, e) { const s = new.target.prototype; super(t), this.transport = e, this.errorType = "FailedToStartTransportError", this.__proto__ = s } } class a extends Error { constructor(t) { const e = new.target.prototype; super(t), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = e } } class l extends Error { constructor(t, e) { const s = new.target.prototype; super(t), this.innerErrors = e, this.__proto__ = s } } class u { constructor(t, e, s) { this.statusCode = t, this.statusText = e, this.content = s } } class d { get(t, e) { return this.send({ ...e, method: "GET", url: t }) } post(t, e) { return this.send({ ...e, method: "POST", url: t }) } delete(t, e) { return this.send({ ...e, method: "DELETE", url: t }) } getCookieString(t) { return "" } } !function (t) { t[t.Trace = 0] = "Trace", t[t.Debug = 1] = "Debug", t[t.Information = 2] = "Information", t[t.Warning = 3] = "Warning", t[t.Error = 4] = "Error", t[t.Critical = 5] = "Critical", t[t.None = 6] = "None" }(e || (e = {})); class f { constructor() { } log(t, e) { } } f.instance = new f; const p = "8.0.0"; class w { static isRequired(t, e) { if (null == t) throw new Error(`The '${e}' argument is required.`) } static isNotEmpty(t, e) { if (!t || t.match(/^\s*$/)) throw new Error(`The '${e}' argument should not be empty.`) } static isIn(t, e, s) { if (!(t in e)) throw new Error(`Unknown ${s} value: ${t}.`) } } class g { static get isBrowser() { return !g.isNode && "object" == typeof window && "object" == typeof window.document } static get isWebWorker() { return !g.isNode && "object" == typeof self && "importScripts" in self } static get isReactNative() { return !g.isNode && "object" == typeof window && void 0 === window.document } static get isNode() { return "undefined" != typeof process && process.release && "node" === process.release.name } } function m(t, e) { let s = ""; return y(t) ? (s = `Binary data of length ${t.byteLength}`, e && (s += `. Content: '${function (t) { const e = new Uint8Array(t); let s = ""; return e.forEach((t => { s += `0x${t < 16 ? "0" : ""}${t.toString(16)} ` })), s.substr(0, s.length - 1) }(t)}'`)) : "string" == typeof t && (s = `String data of length ${t.length}`, e && (s += `. Content: '${t}'`)), s } function y(t) { return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name) } async function b(t, s, i, n, r, o) { const h = {}, [c, a] = $(); h[c] = a, t.log(e.Trace, `(${s} transport) sending data. ${m(r, o.logMessageContent)}.`); const l = y(r) ? "arraybuffer" : "text", u = await i.post(n, { content: r, headers: { ...h, ...o.headers }, responseType: l, timeout: o.timeout, withCredentials: o.withCredentials }); t.log(e.Trace, `(${s} transport) request complete. Response status: ${u.statusCode}.`) } class v { constructor(t, e) { this.i = t, this.h = e } dispose() { const t = this.i.observers.indexOf(this.h); t > -1 && this.i.observers.splice(t, 1), 0 === this.i.observers.length && this.i.cancelCallback && this.i.cancelCallback().catch((t => { })) } } class E { constructor(t) { this.l = t, this.out = console } log(t, s) { if (t >= this.l) { const i = `[${(new Date).toISOString()}] ${e[t]}: ${s}`; switch (t) { case e.Critical: case e.Error: this.out.error(i); break; case e.Warning: this.out.warn(i); break; case e.Information: this.out.info(i); break; default: this.out.log(i) } } } } function $() { let t = "X-SignalR-User-Agent"; return g.isNode && (t = "User-Agent"), [t, C(p, S(), g.isNode ? "NodeJS" : "Browser", k())] } function C(t, e, s, i) { let n = "Microsoft SignalR/"; const r = t.split("."); return n += `${r[0]}.${r[1]}`, n += ` (${t}; `, n += e && "" !== e ? `${e}; ` : "Unknown OS; ", n += `${s}`, n += i ? `; ${i}` : "; Unknown Runtime Version", n += ")", n } function S() { if (!g.isNode) return ""; switch (process.platform) { case "win32": return "Windows NT"; case "darwin": return "macOS"; case "linux": return "Linux"; default: return process.platform } } function k() { if (g.isNode) return process.versions.node } function P(t) { return t.stack ? t.stack : t.message ? t.message : `${t}` } class T extends d { constructor(e) { super(), this.u = e, this.p = fetch.bind(function () { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if (void 0 !== t.g) return t.g; throw new Error("could not find global") }()), this.m = AbortController, this.m } async send(t) { if (t.abortSignal && t.abortSignal.aborted) throw new r; if (!t.method) throw new Error("No method defined."); if (!t.url) throw new Error("No url defined."); const s = new this.m; let o; t.abortSignal && (t.abortSignal.onabort = () => { s.abort(), o = new r }); let h, c = null; if (t.timeout) { const i = t.timeout; c = setTimeout((() => { s.abort(), this.u.log(e.Warning, "Timeout from HTTP request."), o = new n }), i) } "" === t.content && (t.content = void 0), t.content && (t.headers = t.headers || {}, y(t.content) ? t.headers["Content-Type"] = "application/octet-stream" : t.headers["Content-Type"] = "text/plain;charset=UTF-8"); try { h = await this.p(t.url, { body: t.content, cache: "no-cache", credentials: !0 === t.withCredentials ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...t.headers }, method: t.method, mode: "cors", redirect: "follow", signal: s.signal }) } catch (t) { if (o) throw o; throw this.u.log(e.Warning, `Error from HTTP request. ${t}.`), t } finally { c && clearTimeout(c), t.abortSignal && (t.abortSignal.onabort = null) } if (!h.ok) { const t = await I(h, "text"); throw new i(t || h.statusText, h.status) } const a = I(h, t.responseType), l = await a; return new u(h.status, h.statusText, l) } getCookieString(t) { let e = ""; return g.isNode && this.v && this.v.getCookies(t, ((t, s) => e = s.join("; "))), e } } function I(t, e) { let s; switch (e) { case "arraybuffer": s = t.arrayBuffer(); break; case "text": default: s = t.text(); break; case "blob": case "document": case "json": throw new Error(`${e} is not supported.`) }return s } class _ extends d { constructor(t) { super(), this.u = t } send(t) { return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r) : t.method ? t.url ? new Promise(((s, o) => { const h = new XMLHttpRequest; h.open(t.method, t.url, !0), h.withCredentials = void 0 === t.withCredentials || t.withCredentials, h.setRequestHeader("X-Requested-With", "XMLHttpRequest"), "" === t.content && (t.content = void 0), t.content && (y(t.content) ? h.setRequestHeader("Content-Type", "application/octet-stream") : h.setRequestHeader("Content-Type", "text/plain;charset=UTF-8")); const c = t.headers; c && Object.keys(c).forEach((t => { h.setRequestHeader(t, c[t]) })), t.responseType && (h.responseType = t.responseType), t.abortSignal && (t.abortSignal.onabort = () => { h.abort(), o(new r) }), t.timeout && (h.timeout = t.timeout), h.onload = () => { t.abortSignal && (t.abortSignal.onabort = null), h.status >= 200 && h.status < 300 ? s(new u(h.status, h.statusText, h.response || h.responseText)) : o(new i(h.response || h.responseText || h.statusText, h.status)) }, h.onerror = () => { this.u.log(e.Warning, `Error from HTTP request. ${h.status}: ${h.statusText}.`), o(new i(h.statusText, h.status)) }, h.ontimeout = () => { this.u.log(e.Warning, "Timeout from HTTP request."), o(new n) }, h.send(t.content) })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } } class H extends d { constructor(t) { if (super(), "undefined" != typeof fetch || g.isNode) this.$ = new T(t); else { if ("undefined" == typeof XMLHttpRequest) throw new Error("No usable HttpClient found."); this.$ = new _(t) } } send(t) { return t.abortSignal && t.abortSignal.aborted ? Promise.reject(new r) : t.method ? t.url ? this.$.send(t) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } getCookieString(t) { return this.$.getCookieString(t) } } class D { static write(t) { return `${t}${D.RecordSeparator}` } static parse(t) { if (t[t.length - 1] !== D.RecordSeparator) throw new Error("Message is incomplete."); const e = t.split(D.RecordSeparator); return e.pop(), e } } D.RecordSeparatorCode = 30, D.RecordSeparator = String.fromCharCode(D.RecordSeparatorCode); class R { writeHandshakeRequest(t) { return D.write(JSON.stringify(t)) } parseHandshakeResponse(t) { let e, s; if (y(t)) { const i = new Uint8Array(t), n = i.indexOf(D.RecordSeparatorCode); if (-1 === n) throw new Error("Message is incomplete."); const r = n + 1; e = String.fromCharCode.apply(null, Array.prototype.slice.call(i.slice(0, r))), s = i.byteLength > r ? i.slice(r).buffer : null } else { const i = t, n = i.indexOf(D.RecordSeparator); if (-1 === n) throw new Error("Message is incomplete."); const r = n + 1; e = i.substring(0, r), s = i.length > r ? i.substring(r) : null } const i = D.parse(e), n = JSON.parse(i[0]); if (n.type) throw new Error("Expected a handshake response from the server."); return [s, n] } } var x, A; !function (t) { t[t.Invocation = 1] = "Invocation", t[t.StreamItem = 2] = "StreamItem", t[t.Completion = 3] = "Completion", t[t.StreamInvocation = 4] = "StreamInvocation", t[t.CancelInvocation = 5] = "CancelInvocation", t[t.Ping = 6] = "Ping", t[t.Close = 7] = "Close", t[t.Ack = 8] = "Ack", t[t.Sequence = 9] = "Sequence" }(x || (x = {})); class U { constructor() { this.observers = [] } next(t) { for (const e of this.observers) e.next(t) } error(t) { for (const e of this.observers) e.error && e.error(t) } complete() { for (const t of this.observers) t.complete && t.complete() } subscribe(t) { return this.observers.push(t), new v(this, t) } } class L { constructor(t, e, s) { this.C = 1e5, this.S = [], this.k = 0, this.P = !1, this.T = 1, this.I = 0, this._ = 0, this.H = !1, this.D = t, this.R = e, this.C = s } async A(t) { const e = this.D.writeMessage(t); let s = Promise.resolve(); if (this.U(t)) { this.k++; let t = () => { }, i = () => { }; y(e) ? this._ += e.byteLength : this._ += e.length, this._ >= this.C && (s = new Promise(((e, s) => { t = e, i = s }))), this.S.push(new N(e, this.k, t, i)) } try { this.H || await this.R.send(e) } catch { this.L() } await s } N(t) { let e = -1; for (let s = 0; s < this.S.length; s++) { const i = this.S[s]; if (i.q <= t.sequenceId) e = s, y(i.M) ? this._ -= i.M.byteLength : this._ -= i.M.length, i.j(); else { if (!(this._ < this.C)) break; i.j() } } -1 !== e && (this.S = this.S.slice(e + 1)) } W(t) { if (this.P) return t.type === x.Sequence && (this.P = !1, !0); if (!this.U(t)) return !0; const e = this.T; return this.T++, e <= this.I ? (e === this.I && this.O(), !1) : (this.I = e, this.O(), !0) } F(t) { t.sequenceId > this.T ? this.R.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this.T = t.sequenceId } L() { this.H = !0, this.P = !0 } async B() { const t = 0 !== this.S.length ? this.S[0].q : this.k + 1; await this.R.send(this.D.writeMessage({ type: x.Sequence, sequenceId: t })); const e = this.S; for (const t of e) await this.R.send(t.M); this.H = !1 } X(t) { null != t || (t = new Error("Unable to reconnect to server.")); for (const e of this.S) e.J(t) } U(t) { switch (t.type) { case x.Invocation: case x.StreamItem: case x.Completion: case x.StreamInvocation: case x.CancelInvocation: return !0; case x.Close: case x.Sequence: case x.Ping: case x.Ack: return !1 } } O() { void 0 === this.V && (this.V = setTimeout((async () => { try { this.H || await this.R.send(this.D.writeMessage({ type: x.Ack, sequenceId: this.I })) } catch { } clearTimeout(this.V), this.V = void 0 }), 1e3)) } } class N { constructor(t, e, s, i) { this.M = t, this.q = e, this.j = s, this.J = i } } !function (t) { t.Disconnected = "Disconnected", t.Connecting = "Connecting", t.Connected = "Connected", t.Disconnecting = "Disconnecting", t.Reconnecting = "Reconnecting" }(A || (A = {})); class q { static create(t, e, s, i, n, r, o) { return new q(t, e, s, i, n, r, o) } constructor(t, s, i, n, r, o, h) { this.K = 0, this.G = () => { this.u.log(e.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep") }, w.isRequired(t, "connection"), w.isRequired(s, "logger"), w.isRequired(i, "protocol"), this.serverTimeoutInMilliseconds = null != r ? r : 3e4, this.keepAliveIntervalInMilliseconds = null != o ? o : 15e3, this.Y = null != h ? h : 1e5, this.u = s, this.D = i, this.connection = t, this.Z = n, this.tt = new R, this.connection.onreceive = t => this.et(t), this.connection.onclose = t => this.st(t), this.it = {}, this.nt = {}, this.rt = [], this.ot = [], this.ht = [], this.ct = 0, this.lt = !1, this.ut = A.Disconnected, this.dt = !1, this.ft = this.D.writeMessage({ type: x.Ping }) } get state() { return this.ut } get connectionId() { return this.connection && this.connection.connectionId || null } get baseUrl() { return this.connection.baseUrl || "" } set baseUrl(t) { if (this.ut !== A.Disconnected && this.ut !== A.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url."); if (!t) throw new Error("The HubConnection url must be a valid url."); this.connection.baseUrl = t } start() { return this.wt = this.gt(), this.wt } async gt() { if (this.ut !== A.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state.")); this.ut = A.Connecting, this.u.log(e.Debug, "Starting HubConnection."); try { await this.yt(), g.isBrowser && window.document.addEventListener("freeze", this.G), this.ut = A.Connected, this.dt = !0, this.u.log(e.Debug, "HubConnection connected successfully.") } catch (t) { return this.ut = A.Disconnected, this.u.log(e.Debug, `HubConnection failed to start successfully because of error '${t}'.`), Promise.reject(t) } } async yt() { this.bt = void 0, this.lt = !1; const t = new Promise(((t, e) => { this.vt = t, this.Et = e })); await this.connection.start(this.D.transferFormat); try { let s = this.D.version; this.connection.features.reconnect || (s = 1); const i = { protocol: this.D.name, version: s }; if (this.u.log(e.Debug, "Sending handshake request."), await this.$t(this.tt.writeHandshakeRequest(i)), this.u.log(e.Information, `Using HubProtocol '${this.D.name}'.`), this.Ct(), this.St(), this.kt(), await t, this.bt) throw this.bt; !!this.connection.features.reconnect && (this.Pt = new L(this.D, this.connection, this.Y), this.connection.features.disconnected = this.Pt.L.bind(this.Pt), this.connection.features.resend = () => { if (this.Pt) return this.Pt.B() }), this.connection.features.inherentKeepAlive || await this.$t(this.ft) } catch (t) { throw this.u.log(e.Debug, `Hub handshake failed with error '${t}' during start(). Stopping HubConnection.`), this.Ct(), this.Tt(), await this.connection.stop(t), t } } async stop() { const t = this.wt; this.connection.features.reconnect = !1, this.It = this._t(), await this.It; try { await t } catch (t) { } } _t(t) { if (this.ut === A.Disconnected) return this.u.log(e.Debug, `Call to HubConnection.stop(${t}) ignored because it is already in the disconnected state.`), Promise.resolve(); if (this.ut === A.Disconnecting) return this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this.It; const s = this.ut; return this.ut = A.Disconnecting, this.u.log(e.Debug, "Stopping HubConnection."), this.Ht ? (this.u.log(e.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this.Ht), this.Ht = void 0, this.Dt(), Promise.resolve()) : (s === A.Connected && this.Rt(), this.Ct(), this.Tt(), this.bt = t || new r("The connection was stopped before the hub handshake could complete."), this.connection.stop(t)) } async Rt() { try { await this.xt(this.At()) } catch { } } stream(t, ...e) { const [s, i] = this.Ut(e), n = this.Lt(t, e, i); let r; const o = new U; return o.cancelCallback = () => { const t = this.Nt(n.invocationId); return delete this.it[n.invocationId], r.then((() => this.xt(t))) }, this.it[n.invocationId] = (t, e) => { e ? o.error(e) : t && (t.type === x.Completion ? t.error ? o.error(new Error(t.error)) : o.complete() : o.next(t.item)) }, r = this.xt(n).catch((t => { o.error(t), delete this.it[n.invocationId] })), this.qt(s, r), o } $t(t) { return this.kt(), this.connection.send(t) } xt(t) { return this.Pt ? this.Pt.A(t) : this.$t(this.D.writeMessage(t)) } send(t, ...e) { const [s, i] = this.Ut(e), n = this.xt(this.Mt(t, e, !0, i)); return this.qt(s, n), n } invoke(t, ...e) { const [s, i] = this.Ut(e), n = this.Mt(t, e, !1, i); return new Promise(((t, e) => { this.it[n.invocationId] = (s, i) => { i ? e(i) : s && (s.type === x.Completion ? s.error ? e(new Error(s.error)) : t(s.result) : e(new Error(`Unexpected message type: ${s.type}`))) }; const i = this.xt(n).catch((t => { e(t), delete this.it[n.invocationId] })); this.qt(s, i) })) } on(t, e) { t && e && (t = t.toLowerCase(), this.nt[t] || (this.nt[t] = []), -1 === this.nt[t].indexOf(e) && this.nt[t].push(e)) } off(t, e) { if (!t) return; t = t.toLowerCase(); const s = this.nt[t]; if (s) if (e) { const i = s.indexOf(e); -1 !== i && (s.splice(i, 1), 0 === s.length && delete this.nt[t]) } else delete this.nt[t] } onclose(t) { t && this.rt.push(t) } onreconnecting(t) { t && this.ot.push(t) } onreconnected(t) { t && this.ht.push(t) } et(t) { if (this.Ct(), this.lt || (t = this.jt(t), this.lt = !0), t) { const s = this.D.parseMessages(t, this.u); for (const t of s) if (!this.Pt || this.Pt.W(t)) switch (t.type) { case x.Invocation: this.Wt(t); break; case x.StreamItem: case x.Completion: { const s = this.it[t.invocationId]; if (s) { t.type === x.Completion && delete this.it[t.invocationId]; try { s(t) } catch (t) { this.u.log(e.Error, `Stream callback threw error: ${P(t)}`) } } break } case x.Ping: break; case x.Close: { this.u.log(e.Information, "Close message received from server."); const s = t.error ? new Error("Server returned an error on close: " + t.error) : void 0; !0 === t.allowReconnect ? this.connection.stop(s) : this.It = this._t(s); break } case x.Ack: this.Pt && this.Pt.N(t); break; case x.Sequence: this.Pt && this.Pt.F(t); break; default: this.u.log(e.Warning, `Invalid message type: ${t.type}.`) } } this.St() } jt(t) { let s, i; try { [i, s] = this.tt.parseHandshakeResponse(t) } catch (t) { const s = "Error parsing handshake response: " + t; this.u.log(e.Error, s); const i = new Error(s); throw this.Et(i), i } if (s.error) { const t = "Server returned handshake error: " + s.error; this.u.log(e.Error, t); const i = new Error(t); throw this.Et(i), i } return this.u.log(e.Debug, "Server handshake complete."), this.vt(), i } kt() { this.connection.features.inherentKeepAlive || (this.K = (new Date).getTime() + this.keepAliveIntervalInMilliseconds, this.Tt()) } St() { if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this.Ot = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), void 0 !== this.Ft))) { let t = this.K - (new Date).getTime(); t < 0 && (t = 0), this.Ft = setTimeout((async () => { if (this.ut === A.Connected) try { await this.$t(this.ft) } catch { this.Tt() } }), t) } } serverTimeout() { this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server.")) } async Wt(t) { const s = t.target.toLowerCase(), i = this.nt[s]; if (!i) return this.u.log(e.Warning, `No client method with the name '${s}' found.`), void (t.invocationId && (this.u.log(e.Warning, `No result given for '${s}' method and invocation ID '${t.invocationId}'.`), await this.xt(this.Bt(t.invocationId, "Client didn't provide a result.", null)))); const n = i.slice(), r = !!t.invocationId; let o, h, c; for (const i of n) try { const n = o; o = await i.apply(this, t.arguments), r && o && n && (this.u.log(e.Error, `Multiple results provided for '${s}'. Sending error to server.`), c = this.Bt(t.invocationId, "Client provided multiple results.", null)), h = void 0 } catch (t) { h = t, this.u.log(e.Error, `A callback for the method '${s}' threw error '${t}'.`) } c ? await this.xt(c) : r ? (h ? c = this.Bt(t.invocationId, `${h}`, null) : void 0 !== o ? c = this.Bt(t.invocationId, null, o) : (this.u.log(e.Warning, `No result given for '${s}' method and invocation ID '${t.invocationId}'.`), c = this.Bt(t.invocationId, "Client didn't provide a result.", null)), await this.xt(c)) : o && this.u.log(e.Error, `Result given for '${s}' method but server is not expecting a result.`) } st(t) { this.u.log(e.Debug, `HubConnection.connectionClosed(${t}) called while in state ${this.ut}.`), this.bt = this.bt || t || new r("The underlying connection was closed before the hub handshake could complete."), this.vt && this.vt(), this.Xt(t || new Error("Invocation canceled due to the underlying connection being closed.")), this.Ct(), this.Tt(), this.ut === A.Disconnecting ? this.Dt(t) : this.ut === A.Connected && this.Z ? this.Jt(t) : this.ut === A.Connected && this.Dt(t) } Dt(t) { if (this.dt) { this.ut = A.Disconnected, this.dt = !1, this.Pt && (this.Pt.X(null != t ? t : new Error("Connection closed.")), this.Pt = void 0), g.isBrowser && window.document.removeEventListener("freeze", this.G); try { this.rt.forEach((e => e.apply(this, [t]))) } catch (s) { this.u.log(e.Error, `An onclose callback called with error '${t}' threw error '${s}'.`) } } } async Jt(t) { const s = Date.now(); let i = 0, n = void 0 !== t ? t : new Error("Attempting to reconnect due to a unknown error."), r = this.zt(i++, 0, n); if (null === r) return this.u.log(e.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this.Dt(t); if (this.ut = A.Reconnecting, t ? this.u.log(e.Information, `Connection reconnecting because of error '${t}'.`) : this.u.log(e.Information, "Connection reconnecting."), 0 !== this.ot.length) { try { this.ot.forEach((e => e.apply(this, [t]))) } catch (s) { this.u.log(e.Error, `An onreconnecting callback called with error '${t}' threw error '${s}'.`) } if (this.ut !== A.Reconnecting) return void this.u.log(e.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.") } for (; null !== r;) { if (this.u.log(e.Information, `Reconnect attempt number ${i} will start in ${r} ms.`), await new Promise((t => { this.Ht = setTimeout(t, r) })), this.Ht = void 0, this.ut !== A.Reconnecting) return void this.u.log(e.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting."); try { if (await this.yt(), this.ut = A.Connected, this.u.log(e.Information, "HubConnection reconnected successfully."), 0 !== this.ht.length) try { this.ht.forEach((t => t.apply(this, [this.connection.connectionId]))) } catch (t) { this.u.log(e.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${t}'.`) } return } catch (t) { if (this.u.log(e.Information, `Reconnect attempt failed because of error '${t}'.`), this.ut !== A.Reconnecting) return this.u.log(e.Debug, `Connection moved to the '${this.ut}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this.ut === A.Disconnecting && this.Dt()); n = t instanceof Error ? t : new Error(t.toString()), r = this.zt(i++, Date.now() - s, n) } } this.u.log(e.Information, `Reconnect retries have been exhausted after ${Date.now() - s} ms and ${i} failed attempts. Connection disconnecting.`), this.Dt() } zt(t, s, i) { try { return this.Z.nextRetryDelayInMilliseconds({ elapsedMilliseconds: s, previousRetryCount: t, retryReason: i }) } catch (i) { return this.u.log(e.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${t}, ${s}) threw error '${i}'.`), null } } Xt(t) { const s = this.it; this.it = {}, Object.keys(s).forEach((i => { const n = s[i]; try { n(null, t) } catch (s) { this.u.log(e.Error, `Stream 'error' callback called with '${t}' threw error: ${P(s)}`) } })) } Tt() { this.Ft && (clearTimeout(this.Ft), this.Ft = void 0) } Ct() { this.Ot && clearTimeout(this.Ot) } Mt(t, e, s, i) { if (s) return 0 !== i.length ? { arguments: e, streamIds: i, target: t, type: x.Invocation } : { arguments: e, target: t, type: x.Invocation }; { const s = this.ct; return this.ct++, 0 !== i.length ? { arguments: e, invocationId: s.toString(), streamIds: i, target: t, type: x.Invocation } : { arguments: e, invocationId: s.toString(), target: t, type: x.Invocation } } } qt(t, e) { if (0 !== t.length) { e || (e = Promise.resolve()); for (const s in t) t[s].subscribe({ complete: () => { e = e.then((() => this.xt(this.Bt(s)))) }, error: t => { let i; i = t instanceof Error ? t.message : t && t.toString ? t.toString() : "Unknown error", e = e.then((() => this.xt(this.Bt(s, i)))) }, next: t => { e = e.then((() => this.xt(this.Vt(s, t)))) } }) } } Ut(t) { const e = [], s = []; for (let i = 0; i < t.length; i++) { const n = t[i]; if (this.Kt(n)) { const r = this.ct; this.ct++, e[r] = n, s.push(r.toString()), t.splice(i, 1) } } return [e, s] } Kt(t) { return t && t.subscribe && "function" == typeof t.subscribe } Lt(t, e, s) { const i = this.ct; return this.ct++, 0 !== s.length ? { arguments: e, invocationId: i.toString(), streamIds: s, target: t, type: x.StreamInvocation } : { arguments: e, invocationId: i.toString(), target: t, type: x.StreamInvocation } } Nt(t) { return { invocationId: t, type: x.CancelInvocation } } Vt(t, e) { return { invocationId: t, item: e, type: x.StreamItem } } Bt(t, e, s) { return e ? { error: e, invocationId: t, type: x.Completion } : { invocationId: t, result: s, type: x.Completion } } At() { return { type: x.Close } } } const M = [0, 2e3, 1e4, 3e4, null]; class j { constructor(t) { this.Gt = void 0 !== t ? [...t, null] : M } nextRetryDelayInMilliseconds(t) { return this.Gt[t.previousRetryCount] } } class W { } W.Authorization = "Authorization", W.Cookie = "Cookie"; class O extends d { constructor(t, e) { super(), this.Qt = t, this.Yt = e } async send(t) { let e = !0; this.Yt && (!this.Zt || t.url && t.url.indexOf("/negotiate?") > 0) && (e = !1, this.Zt = await this.Yt()), this.te(t); const s = await this.Qt.send(t); return e && 401 === s.statusCode && this.Yt ? (this.Zt = await this.Yt(), this.te(t), await this.Qt.send(t)) : s } te(t) { t.headers || (t.headers = {}), this.Zt ? t.headers[W.Authorization] = `Bearer ${this.Zt}` : this.Yt && t.headers[W.Authorization] && delete t.headers[W.Authorization] } getCookieString(t) { return this.Qt.getCookieString(t) } } var F, B; !function (t) { t[t.None = 0] = "None", t[t.WebSockets = 1] = "WebSockets", t[t.ServerSentEvents = 2] = "ServerSentEvents", t[t.LongPolling = 4] = "LongPolling" }(F || (F = {})), function (t) { t[t.Text = 1] = "Text", t[t.Binary = 2] = "Binary" }(B || (B = {})); class X { constructor() { this.ee = !1, this.onabort = null } abort() { this.ee || (this.ee = !0, this.onabort && this.onabort()) } get signal() { return this } get aborted() { return this.ee } } class J { get pollAborted() { return this.se.aborted } constructor(t, e, s) { this.$ = t, this.u = e, this.se = new X, this.ie = s, this.ne = !1, this.onreceive = null, this.onclose = null } async connect(t, s) { if (w.isRequired(t, "url"), w.isRequired(s, "transferFormat"), w.isIn(s, B, "transferFormat"), this.re = t, this.u.log(e.Trace, "(LongPolling transport) Connecting."), s === B.Binary && "undefined" != typeof XMLHttpRequest && "string" != typeof (new XMLHttpRequest).responseType) throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported."); const [n, r] = $(), o = { [n]: r, ...this.ie.headers }, h = { abortSignal: this.se.signal, headers: o, timeout: 1e5, withCredentials: this.ie.withCredentials }; s === B.Binary && (h.responseType = "arraybuffer"); const c = `${t}&_=${Date.now()}`; this.u.log(e.Trace, `(LongPolling transport) polling: ${c}.`); const a = await this.$.get(c, h); 200 !== a.statusCode ? (this.u.log(e.Error, `(LongPolling transport) Unexpected response code: ${a.statusCode}.`), this.oe = new i(a.statusText || "", a.statusCode), this.ne = !1) : this.ne = !0, this.he = this.ce(this.re, h) } async ce(t, s) { try { for (; this.ne;)try { const n = `${t}&_=${Date.now()}`; this.u.log(e.Trace, `(LongPolling transport) polling: ${n}.`); const r = await this.$.get(n, s); 204 === r.statusCode ? (this.u.log(e.Information, "(LongPolling transport) Poll terminated by server."), this.ne = !1) : 200 !== r.statusCode ? (this.u.log(e.Error, `(LongPolling transport) Unexpected response code: ${r.statusCode}.`), this.oe = new i(r.statusText || "", r.statusCode), this.ne = !1) : r.content ? (this.u.log(e.Trace, `(LongPolling transport) data received. ${m(r.content, this.ie.logMessageContent)}.`), this.onreceive && this.onreceive(r.content)) : this.u.log(e.Trace, "(LongPolling transport) Poll timed out, reissuing.") } catch (t) { this.ne ? t instanceof n ? this.u.log(e.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this.oe = t, this.ne = !1) : this.u.log(e.Trace, `(LongPolling transport) Poll errored after shutdown: ${t.message}`) } } finally { this.u.log(e.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this.ae() } } async send(t) { return this.ne ? b(this.u, "LongPolling", this.$, this.re, t, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected")) } async stop() { this.u.log(e.Trace, "(LongPolling transport) Stopping polling."), this.ne = !1, this.se.abort(); try { await this.he, this.u.log(e.Trace, `(LongPolling transport) sending DELETE request to ${this.re}.`); const t = {}, [s, n] = $(); t[s] = n; const r = { headers: { ...t, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials }; let o; try { await this.$.delete(this.re, r) } catch (t) { o = t } o ? o instanceof i && (404 === o.statusCode ? this.u.log(e.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this.u.log(e.Trace, `(LongPolling transport) Error sending a DELETE request: ${o}`)) : this.u.log(e.Trace, "(LongPolling transport) DELETE request accepted.") } finally { this.u.log(e.Trace, "(LongPolling transport) Stop finished."), this.ae() } } ae() { if (this.onclose) { let t = "(LongPolling transport) Firing onclose event."; this.oe && (t += " Error: " + this.oe), this.u.log(e.Trace, t), this.onclose(this.oe) } } } class z { constructor(t, e, s, i) { this.$ = t, this.Zt = e, this.u = s, this.ie = i, this.onreceive = null, this.onclose = null } async connect(t, s) { return w.isRequired(t, "url"), w.isRequired(s, "transferFormat"), w.isIn(s, B, "transferFormat"), this.u.log(e.Trace, "(SSE transport) Connecting."), this.re = t, this.Zt && (t += (t.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this.Zt)}`), new Promise(((i, n) => { let r, o = !1; if (s === B.Text) { if (g.isBrowser || g.isWebWorker) r = new this.ie.EventSource(t, { withCredentials: this.ie.withCredentials }); else { const e = this.$.getCookieString(t), s = {}; s.Cookie = e; const [i, n] = $(); s[i] = n, r = new this.ie.EventSource(t, { withCredentials: this.ie.withCredentials, headers: { ...s, ...this.ie.headers } }) } try { r.onmessage = t => { if (this.onreceive) try { this.u.log(e.Trace, `(SSE transport) data received. ${m(t.data, this.ie.logMessageContent)}.`), this.onreceive(t.data) } catch (t) { return void this.le(t) } }, r.onerror = t => { o ? this.le() : n(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.")) }, r.onopen = () => { this.u.log(e.Information, `SSE connected to ${this.re}`), this.ue = r, o = !0, i() } } catch (t) { return void n(t) } } else n(new Error("The Server-Sent Events transport only supports the 'Text' transfer format")) })) } async send(t) { return this.ue ? b(this.u, "SSE", this.$, this.re, t, this.ie) : Promise.reject(new Error("Cannot send until the transport is connected")) } stop() { return this.le(), Promise.resolve() } le(t) { this.ue && (this.ue.close(), this.ue = void 0, this.onclose && this.onclose(t)) } } class V { constructor(t, e, s, i, n, r) { this.u = s, this.Yt = e, this.de = i, this.fe = n, this.$ = t, this.onreceive = null, this.onclose = null, this.pe = r } async connect(t, s) { let i; return w.isRequired(t, "url"), w.isRequired(s, "transferFormat"), w.isIn(s, B, "transferFormat"), this.u.log(e.Trace, "(WebSockets transport) Connecting."), this.Yt && (i = await this.Yt()), new Promise(((n, r) => { let o; t = t.replace(/^http/, "ws"); const h = this.$.getCookieString(t); let c = !1; if (g.isNode || g.isReactNative) { const e = {}, [s, n] = $(); e[s] = n, i && (e[W.Authorization] = `Bearer ${i}`), h && (e[W.Cookie] = h), o = new this.fe(t, void 0, { headers: { ...e, ...this.pe } }) } else i && (t += (t.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(i)}`); o || (o = new this.fe(t)), s === B.Binary && (o.binaryType = "arraybuffer"), o.onopen = s => { this.u.log(e.Information, `WebSocket connected to ${t}.`), this.we = o, c = !0, n() }, o.onerror = t => { let s = null; s = "undefined" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : "There was an error with the transport", this.u.log(e.Information, `(WebSockets transport) ${s}.`) }, o.onmessage = t => { if (this.u.log(e.Trace, `(WebSockets transport) data received. ${m(t.data, this.de)}.`), this.onreceive) try { this.onreceive(t.data) } catch (t) { return void this.le(t) } }, o.onclose = t => { if (c) this.le(t); else { let e = null; e = "undefined" != typeof ErrorEvent && t instanceof ErrorEvent ? t.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", r(new Error(e)) } } })) } send(t) { return this.we && this.we.readyState === this.fe.OPEN ? (this.u.log(e.Trace, `(WebSockets transport) sending data. ${m(t, this.de)}.`), this.we.send(t), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state") } stop() { return this.we && this.le(void 0), Promise.resolve() } le(t) { this.we && (this.we.onclose = () => { }, this.we.onmessage = () => { }, this.we.onerror = () => { }, this.we.close(), this.we = void 0), this.u.log(e.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this.ge(t) || !1 !== t.wasClean && 1e3 === t.code ? t instanceof Error ? this.onclose(t) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${t.code} (${t.reason || "no reason given"}).`))) } ge(t) { return t && "boolean" == typeof t.wasClean && "number" == typeof t.code } } class K { constructor(t, s = {}) { var i; if (this.me = () => { }, this.features = {}, this.ye = 1, w.isRequired(t, "url"), this.u = void 0 === (i = s.logger) ? new E(e.Information) : null === i ? f.instance : void 0 !== i.log ? i : new E(i), this.baseUrl = this.be(t), (s = s || {}).logMessageContent = void 0 !== s.logMessageContent && s.logMessageContent, "boolean" != typeof s.withCredentials && void 0 !== s.withCredentials) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value"); s.withCredentials = void 0 === s.withCredentials || s.withCredentials, s.timeout = void 0 === s.timeout ? 1e5 : s.timeout; let n = null, r = null; g.isNode && (n = function () { throw new Error("Trying to import 'ws' in the browser.") }(), r = function () { throw new Error("Trying to import 'eventsource' in the browser.") }()), g.isNode || "undefined" == typeof WebSocket || s.WebSocket ? g.isNode && !s.WebSocket && n && (s.WebSocket = n) : s.WebSocket = WebSocket, g.isNode || "undefined" == typeof EventSource || s.EventSource ? g.isNode && !s.EventSource && void 0 !== r && (s.EventSource = r) : s.EventSource = EventSource, this.$ = new O(s.httpClient || new H(this.u), s.accessTokenFactory), this.ut = "Disconnected", this.dt = !1, this.ie = s, this.onreceive = null, this.onclose = null } async start(t) { if (t = t || B.Binary, w.isIn(t, B, "transferFormat"), this.u.log(e.Debug, `Starting connection with transfer format '${B[t]}'.`), "Disconnected" !== this.ut) return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state.")); if (this.ut = "Connecting", this.ve = this.yt(t), await this.ve, "Disconnecting" === this.ut) { const t = "Failed to start the HttpConnection before stop() was called."; return this.u.log(e.Error, t), await this.It, Promise.reject(new r(t)) } if ("Connected" !== this.ut) { const t = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"; return this.u.log(e.Error, t), Promise.reject(new r(t)) } this.dt = !0 } send(t) { return "Connected" !== this.ut ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this.Ee || (this.Ee = new G(this.transport)), this.Ee.send(t)) } async stop(t) { return "Disconnected" === this.ut ? (this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : "Disconnecting" === this.ut ? (this.u.log(e.Debug, `Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`), this.It) : (this.ut = "Disconnecting", this.It = new Promise((t => { this.me = t })), await this._t(t), void await this.It) } async _t(t) { this.$e = t; try { await this.ve } catch (t) { } if (this.transport) { try { await this.transport.stop() } catch (t) { this.u.log(e.Error, `HttpConnection.transport.stop() threw error '${t}'.`), this.Ce() } this.transport = void 0 } else this.u.log(e.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.") } async yt(t) { let s = this.baseUrl; this.Yt = this.ie.accessTokenFactory, this.$.Yt = this.Yt; try { if (this.ie.skipNegotiation) { if (this.ie.transport !== F.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly."); this.transport = this.Se(F.WebSockets), await this.ke(s, t) } else { let e = null, i = 0; do { if (e = await this.Pe(s), "Disconnecting" === this.ut || "Disconnected" === this.ut) throw new r("The connection was stopped during negotiation."); if (e.error) throw new Error(e.error); if (e.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details."); if (e.url && (s = e.url), e.accessToken) { const t = e.accessToken; this.Yt = () => t, this.$.Zt = t, this.$.Yt = void 0 } i++ } while (e.url && i < 100); if (100 === i && e.url) throw new Error("Negotiate redirection limit exceeded."); await this.Te(s, this.ie.transport, e, t) } this.transport instanceof J && (this.features.inherentKeepAlive = !0), "Connecting" === this.ut && (this.u.log(e.Debug, "The HttpConnection connected successfully."), this.ut = "Connected") } catch (t) { return this.u.log(e.Error, "Failed to start the connection: " + t), this.ut = "Disconnected", this.transport = void 0, this.me(), Promise.reject(t) } } async Pe(t) { const s = {}, [n, r] = $(); s[n] = r; const o = this.Ie(t); this.u.log(e.Debug, `Sending negotiation request: ${o}.`); try { const t = await this.$.post(o, { content: "", headers: { ...s, ...this.ie.headers }, timeout: this.ie.timeout, withCredentials: this.ie.withCredentials }); if (200 !== t.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${t.statusCode}'`)); const e = JSON.parse(t.content); return (!e.negotiateVersion || e.negotiateVersion < 1) && (e.connectionToken = e.connectionId), e.useStatefulReconnect && !0 !== this.ie._e ? Promise.reject(new a("Client didn't negotiate Stateful Reconnect but the server did.")) : e } catch (t) { let s = "Failed to complete negotiation with the server: " + t; return t instanceof i && 404 === t.statusCode && (s += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this.u.log(e.Error, s), Promise.reject(new a(s)) } } He(t, e) { return e ? t + (-1 === t.indexOf("?") ? "?" : "&") + `id=${e}` : t } async Te(t, s, i, n) { let o = this.He(t, i.connectionToken); if (this.De(s)) return this.u.log(e.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = s, await this.ke(o, n), void (this.connectionId = i.connectionId); const h = [], a = i.availableTransports || []; let u = i; for (const i of a) { const a = this.Re(i, s, n, !0 === (null == u ? void 0 : u.useStatefulReconnect)); if (a instanceof Error) h.push(`${i.transport} failed:`), h.push(a); else if (this.De(a)) { if (this.transport = a, !u) { try { u = await this.Pe(t) } catch (t) { return Promise.reject(t) } o = this.He(t, u.connectionToken) } try { return await this.ke(o, n), void (this.connectionId = u.connectionId) } catch (t) { if (this.u.log(e.Error, `Failed to start the transport '${i.transport}': ${t}`), u = void 0, h.push(new c(`${i.transport} failed: ${t}`, F[i.transport])), "Connecting" !== this.ut) { const t = "Failed to select transport before stop() was called."; return this.u.log(e.Debug, t), Promise.reject(new r(t)) } } } } return h.length > 0 ? Promise.reject(new l(`Unable to connect to the server with any of the available transports. ${h.join(" ")}`, h)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server.")) } Se(t) { switch (t) { case F.WebSockets: if (!this.ie.WebSocket) throw new Error("'WebSocket' is not supported in your environment."); return new V(this.$, this.Yt, this.u, this.ie.logMessageContent, this.ie.WebSocket, this.ie.headers || {}); case F.ServerSentEvents: if (!this.ie.EventSource) throw new Error("'EventSource' is not supported in your environment."); return new z(this.$, this.$.Zt, this.u, this.ie); case F.LongPolling: return new J(this.$, this.u, this.ie); default: throw new Error(`Unknown transport: ${t}.`) } } ke(t, e) { return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async s => { let i = !1; if (this.features.reconnect) { try { this.features.disconnected(), await this.transport.connect(t, e), await this.features.resend() } catch { i = !0 } i && this.Ce(s) } else this.Ce(s) } : this.transport.onclose = t => this.Ce(t), this.transport.connect(t, e) } Re(t, s, i, n) { const r = F[t.transport]; if (null == r) return this.u.log(e.Debug, `Skipping transport '${t.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${t.transport}' because it is not supported by this client.`); if (!function (t, e) { return !t || 0 != (e & t) }(s, r)) return this.u.log(e.Debug, `Skipping transport '${F[r]}' because it was disabled by the client.`), new h(`'${F[r]}' is disabled by the client.`, r); if (!(t.transferFormats.map((t => B[t])).indexOf(i) >= 0)) return this.u.log(e.Debug, `Skipping transport '${F[r]}' because it does not support the requested transfer format '${B[i]}'.`), new Error(`'${F[r]}' does not support ${B[i]}.`); if (r === F.WebSockets && !this.ie.WebSocket || r === F.ServerSentEvents && !this.ie.EventSource) return this.u.log(e.Debug, `Skipping transport '${F[r]}' because it is not supported in your environment.'`), new o(`'${F[r]}' is not supported in your environment.`, r); this.u.log(e.Debug, `Selecting transport '${F[r]}'.`); try { return this.features.reconnect = r === F.WebSockets ? n : void 0, this.Se(r) } catch (t) { return t } } De(t) { return t && "object" == typeof t && "connect" in t } Ce(t) { if (this.u.log(e.Debug, `HttpConnection.stopConnection(${t}) called while in state ${this.ut}.`), this.transport = void 0, t = this.$e || t, this.$e = void 0, "Disconnected" !== this.ut) { if ("Connecting" === this.ut) throw this.u.log(e.Warning, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`); if ("Disconnecting" === this.ut && this.me(), t ? this.u.log(e.Error, `Connection disconnected with error '${t}'.`) : this.u.log(e.Information, "Connection disconnected."), this.Ee && (this.Ee.stop().catch((t => { this.u.log(e.Error, `TransportSendQueue.stop() threw error '${t}'.`) })), this.Ee = void 0), this.connectionId = void 0, this.ut = "Disconnected", this.dt) { this.dt = !1; try { this.onclose && this.onclose(t) } catch (s) { this.u.log(e.Error, `HttpConnection.onclose(${t}) threw error '${s}'.`) } } } else this.u.log(e.Debug, `Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`) } be(t) { if (0 === t.lastIndexOf("https://", 0) || 0 === t.lastIndexOf("http://", 0)) return t; if (!g.isBrowser) throw new Error(`Cannot resolve '${t}'.`); const s = window.document.createElement("a"); return s.href = t, this.u.log(e.Information, `Normalizing '${t}' to '${s.href}'.`), s.href } Ie(t) { const e = new URL(t); e.pathname.endsWith("/") ? e.pathname += "negotiate" : e.pathname += "/negotiate"; const s = new URLSearchParams(e.searchParams); return s.has("negotiateVersion") || s.append("negotiateVersion", this.ye.toString()), s.has("useStatefulReconnect") ? "true" === s.get("useStatefulReconnect") && (this.ie._e = !0) : !0 === this.ie._e && s.append("useStatefulReconnect", "true"), e.search = s.toString(), e.toString() } } class G { constructor(t) { this.xe = t, this.Ae = [], this.Ue = !0, this.Le = new Q, this.Ne = new Q, this.qe = this.Me() } send(t) { return this.je(t), this.Ne || (this.Ne = new Q), this.Ne.promise } stop() { return this.Ue = !1, this.Le.resolve(), this.qe } je(t) { if (this.Ae.length && typeof this.Ae[0] != typeof t) throw new Error(`Expected data to be of type ${typeof this.Ae} but was of type ${typeof t}`); this.Ae.push(t), this.Le.resolve() } async Me() { for (; ;) { if (await this.Le.promise, !this.Ue) { this.Ne && this.Ne.reject("Connection stopped."); break } this.Le = new Q; const t = this.Ne; this.Ne = void 0; const e = "string" == typeof this.Ae[0] ? this.Ae.join("") : G.We(this.Ae); this.Ae.length = 0; try { await this.xe.send(e), t.resolve() } catch (e) { t.reject(e) } } } static We(t) { const e = t.map((t => t.byteLength)).reduce(((t, e) => t + e)), s = new Uint8Array(e); let i = 0; for (const e of t) s.set(new Uint8Array(e), i), i += e.byteLength; return s.buffer } } class Q { constructor() { this.promise = new Promise(((t, e) => [this.j, this.Oe] = [t, e])) } resolve() { this.j() } reject(t) { this.Oe(t) } } class Y { constructor() { this.name = "json", this.version = 2, this.transferFormat = B.Text } parseMessages(t, s) { if ("string" != typeof t) throw new Error("Invalid input for JSON hub protocol. Expected a string."); if (!t) return []; null === s && (s = f.instance); const i = D.parse(t), n = []; for (const t of i) { const i = JSON.parse(t); if ("number" != typeof i.type) throw new Error("Invalid payload."); switch (i.type) { case x.Invocation: this.U(i); break; case x.StreamItem: this.Fe(i); break; case x.Completion: this.Be(i); break; case x.Ping: case x.Close: break; case x.Ack: this.Xe(i); break; case x.Sequence: this.Je(i); break; default: s.log(e.Information, "Unknown message type '" + i.type + "' ignored."); continue }n.push(i) } return n } writeMessage(t) { return D.write(JSON.stringify(t)) } U(t) { this.ze(t.target, "Invalid payload for Invocation message."), void 0 !== t.invocationId && this.ze(t.invocationId, "Invalid payload for Invocation message.") } Fe(t) { if (this.ze(t.invocationId, "Invalid payload for StreamItem message."), void 0 === t.item) throw new Error("Invalid payload for StreamItem message.") } Be(t) { if (t.result && t.error) throw new Error("Invalid payload for Completion message."); !t.result && t.error && this.ze(t.error, "Invalid payload for Completion message."), this.ze(t.invocationId, "Invalid payload for Completion message.") } Xe(t) { if ("number" != typeof t.sequenceId) throw new Error("Invalid SequenceId for Ack message.") } Je(t) { if ("number" != typeof t.sequenceId) throw new Error("Invalid SequenceId for Sequence message.") } ze(t, e) { if ("string" != typeof t || "" === t) throw new Error(e) } } const Z = { trace: e.Trace, debug: e.Debug, info: e.Information, information: e.Information, warn: e.Warning, warning: e.Warning, error: e.Error, critical: e.Critical, none: e.None }; class tt { configureLogging(t) { if (w.isRequired(t, "logging"), void 0 !== t.log) this.logger = t; else if ("string" == typeof t) { const e = function (t) { const e = Z[t.toLowerCase()]; if (void 0 !== e) return e; throw new Error(`Unknown log level: ${t}`) }(t); this.logger = new E(e) } else this.logger = new E(t); return this } withUrl(t, e) { return w.isRequired(t, "url"), w.isNotEmpty(t, "url"), this.url = t, this.httpConnectionOptions = "object" == typeof e ? { ...this.httpConnectionOptions, ...e } : { ...this.httpConnectionOptions, transport: e }, this } withHubProtocol(t) { return w.isRequired(t, "protocol"), this.protocol = t, this } withAutomaticReconnect(t) { if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set."); return t ? Array.isArray(t) ? this.reconnectPolicy = new j(t) : this.reconnectPolicy = t : this.reconnectPolicy = new j, this } withServerTimeout(t) { return w.isRequired(t, "milliseconds"), this.Ve = t, this } withKeepAliveInterval(t) { return w.isRequired(t, "milliseconds"), this.Ke = t, this } withStatefulReconnect(t) { return void 0 === this.httpConnectionOptions && (this.httpConnectionOptions = {}), this.httpConnectionOptions._e = !0, this.Y = null == t ? void 0 : t.bufferSize, this } build() { const t = this.httpConnectionOptions || {}; if (void 0 === t.logger && (t.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection."); const e = new K(this.url, t); return q.create(e, this.logger || f.instance, this.protocol || new Y, this.reconnectPolicy, this.Ve, this.Ke, this.Y) } } return Uint8Array.prototype.indexOf || Object.defineProperty(Uint8Array.prototype, "indexOf", { value: Array.prototype.indexOf, writable: !0 }), Uint8Array.prototype.slice || Object.defineProperty(Uint8Array.prototype, "slice", { value: function (t, e) { return new Uint8Array(Array.prototype.slice.call(this, t, e)) }, writable: !0 }), Uint8Array.prototype.forEach || Object.defineProperty(Uint8Array.prototype, "forEach", { value: Array.prototype.forEach, writable: !0 }), s })(), "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.signalR = e() : t.signalR = e();
    //# sourceMappingURL=signalr.min.js.map

</script>
<script>

        const videoBtn = document.getElementById('videoBtn');
        const audioBtn = document.getElementById('audioBtn');
        const videoContainer = document.getElementById('videoContainer');
        const video = document.getElementById('localVideo');
        const video2 = document.getElementById('remoteVideo');
        const closeBtn = document.getElementById('closeBtn');
        const muteBtn = document.getElementById('muteBtn');
        const acceptBtn = document.getElementById('acceptCall');
        const rejectBtn = document.getElementById('rejectCall');

        let connection = null;
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let user;
        let jwtToken;
        let offer;

        let myIce = [];
        let otherIce = [];
        let isSendAnswer = false;
        let isGotAnswer = false;
        let isFinishedCall = false;

        const config = {
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                }
            ]
        };

        videoBtn.addEventListener('click', () => {
            videoBtn.classList.add('hidden');
            audioBtn.classList.add('hidden');
            videoContainer.style.display = 'block';

            call()
                .then(() => console.log('start connection'))
                .catch(err => console.error('Error closing SignalR connection:', err));
        });

        audioBtn.addEventListener('click', () => {
            audioBtn.classList.add('hidden');
            videoBtn.classList.add('hidden');
            videoContainer.style.display = 'block';

            call().then(() => console.log('close connection'))
                .catch(err => console.error('Error closing SignalR connection:', err));
        });


        acceptBtn.addEventListener('click', () => {
            videoBtn.classList.remove('hidden');
            audioBtn.classList.remove('hidden');
            acceptBtn.classList.remove('hidden');
            rejectBtn.classList.remove('hidden');

            videoContainer.style.display = 'block';

            accepttheCallBtn()
                .then(() => console.log('acceoted the call'))
                .catch(err => console.error('Error accepting:', err));
        });

        rejectBtn.addEventListener('click', () => {
            //send event of closing connetion
        });


        closeBtn.addEventListener('click', () => {
            finish();
        });

        muteBtn.addEventListener('click', () => {
            toogleMic();
        });

        function finish() {
            isFinishedCall = true;

            stopCamera();

            videoContainer.style.display = 'none';
            video.pause();
            video.currentTime = 0;
            videoBtn.classList.add('hidden');
            audioBtn.classList.add('hidden');
            acceptBtn.classList.add('hidden');
            rejectBtn.classList.add('hidden');

            connection.invoke("FinishCall", user)
                .then(() => stopConnection())
                .catch(err => console.error('Error ice:', err)); 
        }

       async function createPeerConnection() {
            if (localStream == null) {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                localVideo.onloadedmetadata = () => {
                    localVideo.play();
                };
            }

            if (remoteStream == null) {
                remoteStream = new MediaStream();
                remoteVideo.srcObject = remoteStream;
                remoteVideo.onloadedmetadata = () => {
                    remoteVideo.play();
                }; 
            }

            peerConnection = new RTCPeerConnection(config);
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

            peerConnection.ontrack = (event) => {
                event.streams[0].getTracks().forEach((track) => {
                    remoteStream.addTrack(track);
                });
            };

            peerConnection.onicecandidate = async (event) => {
                if (event.candidate) {
                    if (isSendAnswer == false) {
                        myIce.push(event.candidate);
                    }
                    else {
                        await setIce(event.candidate);
                    } 
                }
            };
        }


        async function call() {
            await startConnection();
            await createPeerConnection();
            await connection.invoke("CallToUser", user);
        }

        async function startConnection() {
            if (connection != null && connection.state != signalR.HubConnectionState.Disconnected) {
                return;
            }

            let url = "http://10.0.2.2:40000/api/signalr";

            connection = new signalR.HubConnectionBuilder()
                .withUrl(url, {
                    accessTokenFactory: () => jwtToken,
                    transport: signalR.HttpTransportType.WebSockets
                })
                .build();

            connection.on("ReceiveOffer", (user, offer) => ReceiveOffer(user, offer));
            connection.on("ReceiveAnswer", (user, answer) => ReceiveAnswer(user, answer));
            connection.on("ReceiveIceCandidate", (user, candidate) => ReceiveIceCandidate(user, candidate));
            connection.on("AccepttheCall", (user) => AccepttheCall(user));
            connection.on("FinishCall", () => FinishCall());

            try {
                console.log("SignalR Connecting");
                await connection.start();
                console.log("SignalR Connected.");
            } catch (err) {
                alert(err);
            }
        }

        function stopConnection() {
            connection.stop()
                .then(() => console.log('close connection'))
                .catch(err => console.error('Error closing SignalR connection:', err));
        }

        function stopCamera() {
            peerConnection.close();

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                const videoElement = document.getElementById('localVideo');
                videoElement.srcObject = null;
            }        
        }

        async function accepttheCallBtn() {
            await startConnection();
            await connection.invoke("AccepttheCall", user);
        }

        function start(token, email, accept) {
            user = email;
            jwtToken = token;

            if (accept * 1 == 1) {
                acceptBtn.classList.remove('hidden');
                rejectBtn.classList.remove('hidden');

                audioBtn.classList.add('hidden');
                videoBtn.classList.add('hidden');
            }
            else {
                videoBtn.classList.remove('hidden');
                audioBtn.classList.remove('hidden');

                acceptBtn.classList.add('hidden');
                rejectBtn.classList.add('hidden');
            }
        }

        function FinishCall() {
            if (!isFinishedCall) {
                finish();
            }
        }

        async function AccepttheCall(user) {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
    
            connection.invoke("SendOffer", user, JSON.stringify(offer)); 
        }

        async function ReceiveOffer(user, offer) {
            await createPeerConnection();
            await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(offer)));

            const answer = await peerConnection.createAnswer();           
            await peerConnection.setLocalDescription(answer);  

            await connection.invoke("SendAnswer", user, JSON.stringify(answer));
            isSendAnswer = true;

            myIce.forEach(ice => {
                setIce(ice);
            });

            otherIce.forEach(ice => {
                setCandidate(ice);
            });
        }

        async function ReceiveAnswer(user, answer) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(answer)));

            myIce.forEach(ice => {
                setIce(ice);
            });

            otherIce.forEach(ice => {
                setCandidate(ice);
            });
        } 

        async function ReceiveIceCandidate(user, candidate) {
            if (isSendAnswer || isGotAnswer) {
                await setCandidate(candidate);
            }
            else {
                otherIce.push(candidate);
            }         
        }

        async function setCandidate(candidate) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(JSON.parse(candidate)));
        }

        async function setIce(candidate) {
            connection.invoke("SendIceCandidate", user, JSON.stringify(candidate))
                .then(() => console.log('send ice'))
                .catch(err => console.error('Error ice:', err));
        }

        function toogleCamera() {
            let videoTrack = localStream.getTracks().find(track => track.kind === 'video');

            if (videoTrack.enabled) {
                videoTrack.enabled = false;
            } else {
                videoTrack.enabled = true;
            }
        }

        function toogleMic() {
            let audioTrack = localStream.getTracks().find(track => track.kind === 'audio');

            if (audioTrack.enabled) {
                audioTrack.enabled = false;
            } else {
                audioTrack.enabled = true;
            }
        }

    </script>
</body>
</html>
